trigger:
  branches:
    include:
    - main
    - develop
  paths:
    include:
    - terraform/*
    - app/*
    - k8s/*
    - pipelines/*

pr:
  branches:
    include:
    - main
    - develop

variables:
  # Azure Configuration
  azureSubscription: 'tf-svc'
  
  # Terraform Backend (Update these for your environment)
  tfBackendResourceGroup: 'rg-terraform-state'
  tfBackendStorageAccount: 'sttfstate'  # Must be globally unique
  tfBackendContainerName: 'tfstate'
  tfBackendKey: 'banking-aks.tfstate'
  
  # Resource Configuration
  resourceGroupName: 'rg-banking-aks-prod'
  
  # Application Configuration
  imageName: 'banking-app'
  k8sNamespace: 'banking'
  
  # Build Configuration
  vmImageName: 'ubuntu-latest'

stages:
#==============================================================================
# STAGE 1: VALIDATE TERRAFORM
#==============================================================================
- stage: Validate
  displayName: 'Validate and Plan'
  jobs:
  - job: ValidateTerraform
    displayName: 'Validate Terraform'
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: TerraformInstaller@0
      displayName: 'Install Terraform'
      inputs:
        terraformVersion: 'latest'

    - task: TerraformTaskV4@4
      displayName: 'Terraform Init'
      inputs:
        provider: 'azurerm'
        command: 'init'
        workingDirectory: '$(System.DefaultWorkingDirectory)/terraform'
        backendServiceArm: '$(azureSubscription)'
        backendAzureRmResourceGroupName: '$(tfBackendResourceGroup)'
        backendAzureRmStorageAccountName: '$(tfBackendStorageAccount)'
        backendAzureRmContainerName: '$(tfBackendContainerName)'
        backendAzureRmKey: '$(tfBackendKey)'

    - task: TerraformTaskV4@4
      displayName: 'Terraform Validate'
      inputs:
        provider: 'azurerm'
        command: 'validate'
        workingDirectory: '$(System.DefaultWorkingDirectory)/terraform'

    - task: TerraformTaskV4@4
      displayName: 'Terraform Plan'
      inputs:
        provider: 'azurerm'
        command: 'plan'
        workingDirectory: '$(System.DefaultWorkingDirectory)/terraform'
        environmentServiceNameAzureRM: '$(azureSubscription)'
        commandOptions: '-out=tfplan'

    - task: PublishPipelineArtifact@1
      displayName: 'Publish Terraform Plan'
      inputs:
        targetPath: '$(System.DefaultWorkingDirectory)/terraform'
        artifact: 'terraform-plan'
        publishLocation: 'pipeline'

#==============================================================================
# STAGE 2: DEPLOY INFRASTRUCTURE
#==============================================================================
- stage: DeployInfrastructure
  displayName: 'Deploy Infrastructure'
  dependsOn: Validate
  condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/main'), eq(variables['Build.SourceBranch'], 'refs/heads/develop')))
  jobs:
  - deployment: DeployTerraform
    displayName: 'Deploy Azure Infrastructure'
    pool:
      vmImage: $(vmImageName)
    environment: 'banking-infrastructure'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self

          - task: TerraformInstaller@0
            displayName: 'Install Terraform'
            inputs:
              terraformVersion: 'latest'

          - task: TerraformTaskV4@4
            displayName: 'Terraform Init'
            inputs:
              provider: 'azurerm'
              command: 'init'
              workingDirectory: '$(System.DefaultWorkingDirectory)/terraform'
              backendServiceArm: '$(azureSubscription)'
              backendAzureRmResourceGroupName: '$(tfBackendResourceGroup)'
              backendAzureRmStorageAccountName: '$(tfBackendStorageAccount)'
              backendAzureRmContainerName: '$(tfBackendContainerName)'
              backendAzureRmKey: '$(tfBackendKey)'

          - task: TerraformTaskV4@4
            displayName: 'Terraform Apply'
            inputs:
              provider: 'azurerm'
              command: 'apply'
              workingDirectory: '$(System.DefaultWorkingDirectory)/terraform'
              environmentServiceNameAzureRM: '$(azureSubscription)'
              commandOptions: '-auto-approve'

          - task: TerraformTaskV4@4
            displayName: 'Terraform Output'
            inputs:
              provider: 'azurerm'
              command: 'output'
              workingDirectory: '$(System.DefaultWorkingDirectory)/terraform'
              outputTo: 'json'

          - task: Bash@3
            displayName: 'Wait for AKS to be Ready'
            inputs:
              targetType: 'inline'
              script: |
                echo "Waiting for AKS cluster to be fully ready..."
                sleep 120
                echo "AKS cluster should be ready now"

#==============================================================================
# STAGE 3: BUILD APPLICATION
#==============================================================================
- stage: BuildApplication
  displayName: 'Build Application'
  dependsOn: DeployInfrastructure
  condition: succeeded()
  jobs:
  - job: BuildDocker
    displayName: 'Build and Push Docker Image'
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: AzureCLI@2
      displayName: 'Build Image using ACR Build Task'
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          set -e
          
          RESOURCE_GROUP="rg-banking-aks-prod"
          IMAGE_NAME="banking-app"
          BUILD_NUMBER="$(Build.BuildNumber)"
          SOURCE_DIR="$(Build.SourcesDirectory)"
          
          echo "Getting ACR information..."
          echo "Resource Group: $RESOURCE_GROUP"
          
          ACR_NAME=$(az acr list --resource-group $RESOURCE_GROUP --query "[0].name" -o tsv)
          
          if [ -z "$ACR_NAME" ]; then
            echo "##[error]No ACR found in resource group $RESOURCE_GROUP"
            echo "Listing all resources in the group:"
            az resource list --resource-group $RESOURCE_GROUP --output table
            exit 1
          fi
          
          echo "ACR Name: $ACR_NAME"
          echo "Building image directly in ACR..."
          
          # Build directly in ACR - this avoids local Docker issues
          az acr build \
            --registry $ACR_NAME \
            --image ${IMAGE_NAME}:${BUILD_NUMBER} \
            --image ${IMAGE_NAME}:latest \
            --file Dockerfile \
            --platform linux \
            ${SOURCE_DIR}/app
          
          ACR_LOGIN_SERVER="${ACR_NAME}.azurecr.io"
          
          echo ""
          echo "‚úì Image built and pushed successfully!"
          echo "  Registry: $ACR_LOGIN_SERVER"
          echo "  Image: ${ACR_LOGIN_SERVER}/${IMAGE_NAME}:${BUILD_NUMBER}"
          echo "  Tags: ${BUILD_NUMBER}, latest"

    - task: PublishPipelineArtifact@1
      displayName: 'Publish K8s Manifests'
      inputs:
        targetPath: '$(Build.SourcesDirectory)/k8s'
        artifact: 'k8s-manifests'
        publishLocation: 'pipeline'

#==============================================================================
# STAGE 4: DEPLOY APPLICATION TO AKS
#==============================================================================
- stage: DeployApplication
  displayName: 'Deploy to AKS'
  dependsOn: 
  - DeployInfrastructure
  - BuildApplication
  condition: succeeded()
  jobs:
  - deployment: DeployToAKS
    displayName: 'Deploy Application to AKS'
    pool:
      vmImage: $(vmImageName)
    environment: 'banking-production'
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: k8s-manifests
            displayName: 'Download K8s Manifests'

          - task: AzureCLI@2
            displayName: 'Get Resources and Deploy'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                set -e
                
                RESOURCE_GROUP="rg-banking-aks-prod"
                IMAGE_NAME="banking-app"
                BUILD_NUMBER="$(Build.BuildNumber)"
                K8S_NAMESPACE="banking"
                WORKSPACE_DIR="$(Pipeline.Workspace)"
                
                echo "Getting resource information..."
                echo "Resource Group: $RESOURCE_GROUP"
                
                # Get resource details
                ACR_LOGIN_SERVER=$(az acr list --resource-group $RESOURCE_GROUP --query "[0].loginServer" -o tsv)
                AKS_NAME=$(az aks list --resource-group $RESOURCE_GROUP --query "[0].name" -o tsv)
                KV_URI=$(az keyvault list --resource-group $RESOURCE_GROUP --query "[0].properties.vaultUri" -o tsv)
                
                echo "ACR Server: $ACR_LOGIN_SERVER"
                echo "AKS Cluster: $AKS_NAME"
                echo "Key Vault: $KV_URI"
                
                # Get AKS credentials
                echo "Getting AKS credentials..."
                az aks get-credentials \
                  --resource-group $RESOURCE_GROUP \
                  --name $AKS_NAME \
                  --overwrite-existing
                
                echo "Verifying connection..."
                kubectl cluster-info
                kubectl get nodes
                
                # Update manifests
                cd ${WORKSPACE_DIR}/k8s-manifests
                
                echo "Updating manifests with actual values..."
                
                # Update deployment with ACR and build number
                sed -i "s|image:.*|image: ${ACR_LOGIN_SERVER}/${IMAGE_NAME}:${BUILD_NUMBER}|g" 03-deployment.yaml
                
                # Update secret with Key Vault URI
                sed -i "s|__KEY_VAULT_URL__|$KV_URI|g" 01-secret.yaml
                
                echo "Updated manifests:"
                echo "Image: ${ACR_LOGIN_SERVER}/${IMAGE_NAME}:${BUILD_NUMBER}"
                echo "Key Vault: $KV_URI"
                
                # Create namespace
                echo "Creating namespace..."
                kubectl apply -f 00-namespace.yaml
                
                # Deploy secrets and config
                echo "Deploying secrets and config..."
                kubectl apply -f 01-secret.yaml -n $K8S_NAMESPACE
                kubectl apply -f 02-configmap.yaml -n $K8S_NAMESPACE
                
                # Deploy application
                echo "Deploying application..."
                kubectl apply -f 03-deployment.yaml -n $K8S_NAMESPACE
                kubectl apply -f 04-service.yaml -n $K8S_NAMESPACE
                kubectl apply -f 05-hpa.yaml -n $K8S_NAMESPACE
                kubectl apply -f 06-network-policy.yaml -n $K8S_NAMESPACE
                
                # Wait for deployment
                echo "Waiting for deployment to complete..."
                kubectl rollout status deployment/banking-app -n $K8S_NAMESPACE --timeout=10m
                
                echo "Checking pod status..."
                kubectl get pods -n $K8S_NAMESPACE

          - task: AzureCLI@2
            displayName: 'Configure Application Gateway'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                RESOURCE_GROUP="rg-banking-aks-prod"
                K8S_NAMESPACE="banking"
                
                echo "Waiting for LoadBalancer IP assignment..."
                
                for i in {1..30}; do
                  INTERNAL_LB_IP=$(kubectl get svc banking-app-service -n $K8S_NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
                  
                  if [ -n "$INTERNAL_LB_IP" ]; then
                    echo "LoadBalancer IP assigned: $INTERNAL_LB_IP"
                    break
                  fi
                  
                  echo "Waiting... (attempt $i/30)"
                  sleep 10
                done
                
                if [ -z "$INTERNAL_LB_IP" ]; then
                  echo "##vso[task.logissue type=warning]LoadBalancer IP not assigned after 5 minutes"
                  exit 0
                fi
                
                echo "Updating Application Gateway backend pool..."
                
                APP_GW_NAME=$(az network application-gateway list --resource-group $RESOURCE_GROUP --query "[0].name" -o tsv)
                
                az network application-gateway address-pool update \
                  --gateway-name $APP_GW_NAME \
                  --resource-group $RESOURCE_GROUP \
                  --name backend-pool \
                  --servers $INTERNAL_LB_IP
                
                echo "Application Gateway updated successfully!"

          - task: AzureCLI@2
            displayName: 'Deployment Summary'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                RESOURCE_GROUP="rg-banking-aks-prod"
                IMAGE_NAME="banking-app"
                BUILD_NUMBER="$(Build.BuildNumber)"
                K8S_NAMESPACE="banking"
                
                # Get Application Gateway IP
                APP_GW_IP=$(az network public-ip show \
                  --resource-group $RESOURCE_GROUP \
                  --name bankaks-appgw-pip \
                  --query ipAddress -o tsv)
                
                ACR_LOGIN_SERVER=$(az acr list --resource-group $RESOURCE_GROUP --query "[0].loginServer" -o tsv)
                AKS_NAME=$(az aks list --resource-group $RESOURCE_GROUP --query "[0].name" -o tsv)
                
                echo "============================================"
                echo "‚úÖ DEPLOYMENT SUCCESSFUL!"
                echo "============================================"
                echo ""
                echo "üåê Application URL:"
                echo "   http://$APP_GW_IP"
                echo ""
                echo "üîê Login Credentials:"
                echo "   Customer ID: 5439090"
                echo "   Password: Passw0rd!!"
                echo ""
                echo "üìä Deployment Details:"
                echo "   Resource Group: $RESOURCE_GROUP"
                echo "   AKS Cluster: $AKS_NAME"
                echo "   Namespace: $K8S_NAMESPACE"
                echo "   Build Number: $BUILD_NUMBER"
                echo "   Image: ${ACR_LOGIN_SERVER}/${IMAGE_NAME}:${BUILD_NUMBER}"
                echo ""
                echo "üîç Verify Deployment:"
                echo "   kubectl get all -n $K8S_NAMESPACE"
                echo "   kubectl logs -f deployment/banking-app -n $K8S_NAMESPACE"
                echo ""
                echo "============================================"

          - task: Bash@3
            displayName: 'Health Check'
            inputs:
              targetType: 'inline'
              script: |
                K8S_NAMESPACE="banking"
                
                echo "Running health checks..."
                
                # Check pods
                READY_PODS=$(kubectl get pods -n $K8S_NAMESPACE -l app=banking-app -o jsonpath='{.items[?(@.status.phase=="Running")].metadata.name}' | wc -w)
                DESIRED_PODS=$(kubectl get deployment banking-app -n $K8S_NAMESPACE -o jsonpath='{.spec.replicas}')
                
                echo "Pods Status: $READY_PODS/$DESIRED_PODS ready"
                
                if [ "$READY_PODS" -eq "$DESIRED_PODS" ]; then
                  echo "‚úÖ All pods are healthy"
                else
                  echo "‚ö†Ô∏è Warning: Not all pods are ready"
                fi
                
                # Display service info
                echo ""
                echo "Service Information:"
                kubectl get svc banking-app-service -n $K8S_NAMESPACE
                
                # Display HPA info
                echo ""
                echo "HPA Status:"
                kubectl get hpa -n $K8S_NAMESPACE