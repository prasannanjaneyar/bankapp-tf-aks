trigger:
  branches:
    include:
    - main
    - develop
  paths:
    include:
    - terraform/*
    - app/*
    - k8s/*
    - pipelines/*

pr:
  branches:
    include:
    - main
    - develop

variables:
  # Azure Configuration
  azureSubscription: 'tf-svc'
  
  # Terraform Backend (Update these for your environment)
  tfBackendResourceGroup: 'tfstate-rg'
  tfBackendStorageAccount: 'tfstatebackendstore6789'  # Must be globally unique
  tfBackendContainerName: 'tfstate'
  tfBackendKey: 'banking-aks.tfstate'
  
  # Application Configuration
  imageName: 'banking-app'
  k8sNamespace: 'banking'
  
  # Build Configuration
  vmImageName: 'ubuntu-latest'

stages:
- stage: Validate
  displayName: 'Validate and Plan'
  jobs:
  - job: ValidateTerraform
    displayName: 'Validate Terraform'
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: TerraformInstaller@0
      displayName: 'Install Terraform'
      inputs:
        terraformVersion: 'latest'

    - task: TerraformTaskV4@4
      displayName: 'Terraform Init'
      inputs:
        provider: 'azurerm'
        command: 'init'
        workingDirectory: '$(System.DefaultWorkingDirectory)/terraform'
        backendServiceArm: '$(azureSubscription)'
        backendAzureRmResourceGroupName: '$(tfBackendResourceGroup)'
        backendAzureRmStorageAccountName: '$(tfBackendStorageAccount)'
        backendAzureRmContainerName: '$(tfBackendContainerName)'
        backendAzureRmKey: '$(tfBackendKey)'

    - task: TerraformTaskV4@4
      displayName: 'Terraform Validate'
      inputs:
        provider: 'azurerm'
        command: 'validate'
        workingDirectory: '$(System.DefaultWorkingDirectory)/terraform'

    - task: TerraformTaskV4@4
      displayName: 'Terraform Plan'
      inputs:
        provider: 'azurerm'
        command: 'plan'
        workingDirectory: '$(System.DefaultWorkingDirectory)/terraform'
        environmentServiceNameAzureRM: '$(azureSubscription)'
        commandOptions: '-out=tfplan'

    - task: PublishPipelineArtifact@1
      displayName: 'Publish Terraform Plan'
      inputs:
        targetPath: '$(System.DefaultWorkingDirectory)/terraform'
        artifact: 'terraform-plan'
        publishLocation: 'pipeline'

- stage: DeployInfrastructure
  displayName: 'Deploy Infrastructure'
  dependsOn: Validate
  condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/main'), eq(variables['Build.SourceBranch'], 'refs/heads/develop')))
  jobs:
  - deployment: DeployTerraform
    displayName: 'Deploy Azure Infrastructure'
    pool:
      vmImage: $(vmImageName)
    environment: 'banking-infrastructure'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self

          - task: TerraformInstaller@0
            displayName: 'Install Terraform'
            inputs:
              terraformVersion: 'latest'

          - task: TerraformTaskV4@4
            displayName: 'Terraform Init'
            inputs:
              provider: 'azurerm'
              command: 'init'
              workingDirectory: '$(System.DefaultWorkingDirectory)/terraform'
              backendServiceArm: '$(azureSubscription)'
              backendAzureRmResourceGroupName: '$(tfBackendResourceGroup)'
              backendAzureRmStorageAccountName: '$(tfBackendStorageAccount)'
              backendAzureRmContainerName: '$(tfBackendContainerName)'
              backendAzureRmKey: '$(tfBackendKey)'

          - task: TerraformTaskV4@4
            displayName: 'Terraform Apply'
            name: TerraformApply
            inputs:
              provider: 'azurerm'
              command: 'apply'
              workingDirectory: '$(System.DefaultWorkingDirectory)/terraform'
              environmentServiceNameAzureRM: '$(azureSubscription)'
              commandOptions: '-auto-approve'

          - task: TerraformTaskV4@4
            displayName: 'Terraform Output'
            inputs:
              provider: 'azurerm'
              command: 'output'
              workingDirectory: '$(System.DefaultWorkingDirectory)/terraform'
              environmentServiceNameAzureRM: 'tf-svc'

          - task: AzureCLI@2
            displayName: 'Save Terraform Outputs'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Extracting Terraform outputs..."
                
                # Get outputs
                RESOURCE_GROUP=$(terraform output -raw resource_group_name)
                AKS_NAME=$(terraform output -raw aks_cluster_name)
                ACR_NAME=$(terraform output -raw acr_name)
                ACR_LOGIN_SERVER=$(terraform output -raw acr_login_server)
                KEY_VAULT_NAME=$(terraform output -raw key_vault_name)
                KEY_VAULT_URI=$(terraform output -raw key_vault_uri)
                APP_GW_IP=$(terraform output -raw application_gateway_public_ip)
                
                # Set pipeline variables
                echo "##vso[task.setvariable variable=resourceGroup;isOutput=true]$RESOURCE_GROUP"
                echo "##vso[task.setvariable variable=aksName;isOutput=true]$AKS_NAME"
                echo "##vso[task.setvariable variable=acrName;isOutput=true]$ACR_NAME"
                echo "##vso[task.setvariable variable=acrLoginServer;isOutput=true]$ACR_LOGIN_SERVER"
                echo "##vso[task.setvariable variable=keyVaultName;isOutput=true]$KEY_VAULT_NAME"
                echo "##vso[task.setvariable variable=keyVaultUri;isOutput=true]$KEY_VAULT_URI"
                echo "##vso[task.setvariable variable=appGatewayIp;isOutput=true]$APP_GW_IP"
                
                echo "Infrastructure deployed successfully!"
                echo "Resource Group: $RESOURCE_GROUP"
                echo "AKS Cluster: $AKS_NAME"
                echo "ACR: $ACR_LOGIN_SERVER"
                echo "Application Gateway IP: $APP_GW_IP"
              workingDirectory: '$(System.DefaultWorkingDirectory)/terraform'

          - task: Bash@3
            displayName: 'Wait for AKS to be Ready'
            inputs:
              targetType: 'inline'
              script: |
                echo "Waiting for AKS cluster to be fully ready..."
                sleep 120
                echo "AKS cluster should be ready now"

#==============================================================================
# STAGE 3: BUILD APPLICATION
#==============================================================================
- stage: BuildApplication
  displayName: 'Build Application'
  dependsOn: DeployInfrastructure
  condition: succeeded()
  jobs:
  - job: BuildDocker
    displayName: 'Build and Push Docker Image'
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: AzureCLI@2
      displayName: 'Get ACR Details and Build Image'
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "Getting ACR information..."
          
          # Get ACR details
          ACR_NAME=$(az acr list --resource-group $(resourceGroupName) --query "[0].name" -o tsv)
          ACR_LOGIN_SERVER=$(az acr list --resource-group $(resourceGroupName) --query "[0].loginServer" -o tsv)
          
          echo "ACR Name: $ACR_NAME"
          echo "ACR Login Server: $ACR_LOGIN_SERVER"
          
          # Login to ACR
          echo "Logging into ACR..."
          az acr login --name $ACR_NAME
          
          # Build image
          echo "Building Docker image..."
          cd $(Build.SourcesDirectory)/app
          docker build -t $(imageName):$(Build.BuildNumber) .
          
          # Tag images
          echo "Tagging images..."
          docker tag $(imageName):$(Build.BuildNumber) $(imageName):latest
          docker tag $(imageName):$(Build.BuildNumber) $ACR_LOGIN_SERVER/$(imageName):$(Build.BuildNumber)
          docker tag $(imageName):$(Build.BuildNumber) $ACR_LOGIN_SERVER/$(imageName):latest
          
          # Push to ACR
          echo "Pushing to ACR..."
          docker push $ACR_LOGIN_SERVER/$(imageName):$(Build.BuildNumber)
          docker push $ACR_LOGIN_SERVER/$(imageName):latest
          
          echo "‚úì Image pushed successfully!"
          echo "  Image: $ACR_LOGIN_SERVER/$(imageName):$(Build.BuildNumber)"

    - task: PublishPipelineArtifact@1
      displayName: 'Publish K8s Manifests'
      inputs:
        targetPath: '$(Build.SourcesDirectory)/k8s'
        artifact: 'k8s-manifests'
        publishLocation: 'pipeline'

#==============================================================================
# STAGE 4: DEPLOY APPLICATION TO AKS
#==============================================================================
- stage: DeployApplication
  displayName: 'Deploy to AKS'
  dependsOn: 
  - DeployInfrastructure
  - BuildApplication
  condition: succeeded()
  jobs:
  - deployment: DeployToAKS
    displayName: 'Deploy Application to AKS'
    pool:
      vmImage: $(vmImageName)
    environment: 'banking-production'
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: k8s-manifests
            displayName: 'Download K8s Manifests'

          - task: AzureCLI@2
            displayName: 'Get Resources and Deploy'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                set -e
                
                echo "Getting resource information..."
                
                # Get resource details
                ACR_LOGIN_SERVER=$(az acr list --resource-group $(resourceGroupName) --query "[0].loginServer" -o tsv)
                AKS_NAME=$(az aks list --resource-group $(resourceGroupName) --query "[0].name" -o tsv)
                KV_URI=$(az keyvault list --resource-group $(resourceGroupName) --query "[0].properties.vaultUri" -o tsv)
                
                echo "ACR Server: $ACR_LOGIN_SERVER"
                echo "AKS Cluster: $AKS_NAME"
                echo "Key Vault: $KV_URI"
                
                # Get AKS credentials
                echo "Getting AKS credentials..."
                az aks get-credentials \
                  --resource-group $(resourceGroupName) \
                  --name $AKS_NAME \
                  --overwrite-existing
                
                echo "Verifying connection..."
                kubectl cluster-info
                kubectl get nodes
                
                # Update manifests
                cd $(Pipeline.Workspace)/k8s-manifests
                
                echo "Updating manifests with actual values..."
                
                # Update deployment with ACR and build number
                sed -i "s|image:.*|image: $ACR_LOGIN_SERVER/$(imageName):$(Build.BuildNumber)|g" 03-deployment.yaml
                
                # Update secret with Key Vault URI
                sed -i "s|__KEY_VAULT_URL__|$KV_URI|g" 01-secret.yaml
                
                echo "Updated manifests:"
                echo "Image: $ACR_LOGIN_SERVER/$(imageName):$(Build.BuildNumber)"
                echo "Key Vault: $KV_URI"
                
                # Create namespace
                echo "Creating namespace..."
                kubectl apply -f 00-namespace.yaml
                
                # Deploy secrets and config
                echo "Deploying secrets and config..."
                kubectl apply -f 01-secret.yaml -n $(k8sNamespace)
                kubectl apply -f 02-configmap.yaml -n $(k8sNamespace)
                
                # Deploy application
                echo "Deploying application..."
                kubectl apply -f 03-deployment.yaml -n $(k8sNamespace)
                kubectl apply -f 04-service.yaml -n $(k8sNamespace)
                kubectl apply -f 05-hpa.yaml -n $(k8sNamespace)
                kubectl apply -f 06-network-policy.yaml -n $(k8sNamespace)
                
                # Wait for deployment
                echo "Waiting for deployment to complete..."
                kubectl rollout status deployment/banking-app -n $(k8sNamespace) --timeout=10m
                
                echo "Checking pod status..."
                kubectl get pods -n $(k8sNamespace)

          - task: AzureCLI@2
            displayName: 'Configure Application Gateway'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Waiting for LoadBalancer IP assignment..."
                
                for i in {1..30}; do
                  INTERNAL_LB_IP=$(kubectl get svc banking-app-service -n $(k8sNamespace) -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
                  
                  if [ -n "$INTERNAL_LB_IP" ]; then
                    echo "LoadBalancer IP assigned: $INTERNAL_LB_IP"
                    break
                  fi
                  
                  echo "Waiting... (attempt $i/30)"
                  sleep 10
                done
                
                if [ -z "$INTERNAL_LB_IP" ]; then
                  echo "##vso[task.logissue type=warning]LoadBalancer IP not assigned after 5 minutes"
                  exit 0
                fi
                
                echo "Updating Application Gateway backend pool..."
                
                APP_GW_NAME=$(az network application-gateway list --resource-group $(resourceGroupName) --query "[0].name" -o tsv)
                
                az network application-gateway address-pool update \
                  --gateway-name $APP_GW_NAME \
                  --resource-group $(resourceGroupName) \
                  --name backend-pool \
                  --servers $INTERNAL_LB_IP
                
                echo "Application Gateway updated successfully!"

          - task: AzureCLI@2
            displayName: 'Deployment Summary'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                # Get Application Gateway IP
                APP_GW_IP=$(az network public-ip show \
                  --resource-group $(resourceGroupName) \
                  --name bankaks-appgw-pip \
                  --query ipAddress -o tsv)
                
                ACR_LOGIN_SERVER=$(az acr list --resource-group $(resourceGroupName) --query "[0].loginServer" -o tsv)
                AKS_NAME=$(az aks list --resource-group $(resourceGroupName) --query "[0].name" -o tsv)
                
                echo "============================================"
                echo "‚úÖ DEPLOYMENT SUCCESSFUL!"
                echo "============================================"
                echo ""
                echo "üåê Application URL:"
                echo "   http://$APP_GW_IP"
                echo ""
                echo "üîê Login Credentials:"
                echo "   Customer ID: 5439090"
                echo "   Password: Passw0rd!!"
                echo ""
                echo "üìä Deployment Details:"
                echo "   Resource Group: $(resourceGroupName)"
                echo "   AKS Cluster: $AKS_NAME"
                echo "   Namespace: $(k8sNamespace)"
                echo "   Build Number: $(Build.BuildNumber)"
                echo "   Image: $ACR_LOGIN_SERVER/$(imageName):$(Build.BuildNumber)"
                echo ""
                echo "üîç Verify Deployment:"
                echo "   kubectl get all -n $(k8sNamespace)"
                echo "   kubectl logs -f deployment/banking-app -n $(k8sNamespace)"
                echo ""
                echo "============================================"

          - task: Bash@3
            displayName: 'Health Check'
            inputs:
              targetType: 'inline'
              script: |
                echo "Running health checks..."
                
                # Check pods
                READY_PODS=$(kubectl get pods -n $(k8sNamespace) -l app=banking-app -o jsonpath='{.items[?(@.status.phase=="Running")].metadata.name}' | wc -w)
                DESIRED_PODS=$(kubectl get deployment banking-app -n $(k8sNamespace) -o jsonpath='{.spec.replicas}')
                
                echo "Pods Status: $READY_PODS/$DESIRED_PODS ready"
                
                if [ "$READY_PODS" -eq "$DESIRED_PODS" ]; then
                  echo "‚úÖ All pods are healthy"
                else
                  echo "‚ö†Ô∏è Warning: Not all pods are ready"
                fi
                
                # Display service info
                echo ""
                echo "Service Information:"
                kubectl get svc banking-app-service -n $(k8sNamespace)
                
                # Display HPA info
                echo ""
                echo "HPA Status:"
                kubectl get hpa -n $(k8sNamespace)
